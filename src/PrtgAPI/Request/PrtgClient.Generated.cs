/************************************************************************************
 * This code was generated by a tool.                                               *
 * Please do not modify this file directly - modify PrtgClient.Generated.tt instead *
 ************************************************************************************/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using PrtgAPI.Attributes;
using PrtgAPI.Parameters;
using PrtgAPI.Parameters.Helpers;
using PrtgAPI.Linq;
using PrtgAPI.Request.Serialization;
using PrtgAPI.Request;
using PrtgAPI.Utilities;

//Methods with complex logic surrounding sync/async function calls.
//For each method, two variants a generated. A synchronous method with the
//expected return type, and an async method that implicitly wraps the result
//in a Task

namespace PrtgAPI
{
    public partial class PrtgClient
    {
        //######################################
        // GetChannelsInternal
        //######################################

        internal List<Channel> GetChannelsInternal(Either<Sensor, int> sensorOrId, Func<string, bool> nameFilter = null, Func<int, bool> idFilter = null, CancellationToken token = default(CancellationToken))
        {
            if (nameFilter == null)
                nameFilter = n => true;

            if (idFilter == null)
                idFilter = i => true;

            var response = ObjectEngine.GetObjectsXml(new ChannelParameters(sensorOrId), token: token);

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            items.Where(e => 
                !nameFilter(e.Element("name").Value?.ToString()) ||
                !idFilter(Convert.ToInt32(e.Element("objid").Value.ToString()))
            ).Remove();

            items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = GetChannelProperties(sensorOrId, id, token);

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorOrId.GetId()));
            }

            if (items.Count > 0)
                return ObjectEngine.XmlEngine.DeserializeTable<Channel>(response.CreateReader()).Items;

            return new List<Channel>();
        }

        internal async Task<List<Channel>> GetChannelsInternalAsync(Either<Sensor, int> sensorOrId, Func<string, bool> nameFilter = null, Func<int, bool> idFilter = null, CancellationToken token = default(CancellationToken))
        {
            if (nameFilter == null)
                nameFilter = n => true;

            if (idFilter == null)
                idFilter = i => true;

            var response = await ObjectEngine.GetObjectsXmlAsync(new ChannelParameters(sensorOrId), token: token).ConfigureAwait(false);

            response.Descendants("item").Where(item => item.Element("objid").Value == "-4").Remove();

            var items = response.Descendants("item").ToList();

            items.Where(e => 
                !nameFilter(e.Element("name").Value?.ToString()) ||
                !idFilter(Convert.ToInt32(e.Element("objid").Value.ToString()))
            ).Remove();

            items = response.Descendants("item").ToList();

            await Task.WhenAll(items.Select(async item =>
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = await GetChannelPropertiesAsync(sensorOrId, id, token).ConfigureAwait(false);

                item.Add(properties.Nodes());
                item.Add(new XElement("injected_sensorId", sensorOrId.GetId()));
            })).ConfigureAwait(false);

            if (items.Count > 0)
                return ObjectEngine.XmlEngine.DeserializeTable<Channel>(response.CreateReader()).Items;

            return new List<Channel>();
        }

        //######################################
        // GetNotificationActionsInternal
        //######################################

        internal List<NotificationAction> GetNotificationActionsInternal(NotificationActionParameters parameters, CancellationToken token)
        {
            var response = ObjectEngine.GetObjectsXml(parameters, token: token);

            var items = response.Descendants("item").ToList();

            foreach (var item in items)
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = GetNotificationActionProperties(id, token);

                item.Add(properties.Nodes());
            }

            var actions = ObjectEngine.XmlEngine.DeserializeTable<NotificationAction>(response.CreateReader()).Items;

            var actionsWithSchedules = ResponseParser.GroupActionSchedules(actions).ToList();

            UpdateActionSchedules(actionsWithSchedules, token);

            return actions;
        }

        internal async Task<List<NotificationAction>> GetNotificationActionsInternalAsync(NotificationActionParameters parameters, CancellationToken token)
        {
            var response = await ObjectEngine.GetObjectsXmlAsync(parameters, token: token).ConfigureAwait(false);

            var items = response.Descendants("item").ToList();

            await Task.WhenAll(items.Select(async item =>
            {
                var id = Convert.ToInt32(item.Element("objid").Value);

                var properties = await GetNotificationActionPropertiesAsync(id, token).ConfigureAwait(false);

                item.Add(properties.Nodes());
            })).ConfigureAwait(false);

            var actions = ObjectEngine.XmlEngine.DeserializeTable<NotificationAction>(response.CreateReader()).Items;

            var actionsWithSchedules = ResponseParser.GroupActionSchedules(actions).ToList();

            await UpdateActionSchedulesAsync(actionsWithSchedules, token).ConfigureAwait(false);

            return actions;
        }

        //######################################
        // GetSchedulesInternal
        //######################################

        internal List<Schedule> GetSchedulesInternal(ScheduleParameters parameters, CancellationToken token)
        {
            var schedules = ObjectEngine.GetObjects<Schedule>(parameters, token: token);

            foreach (var schedule in schedules)
            {
                var response = (GetObjectPropertiesRawInternal(schedule.Id, ObjectType.Schedule, token)).StringValue;
                ResponseParser.LoadTimeTable(schedule, response);
            }

            return schedules;
        }

        internal async Task<List<Schedule>> GetSchedulesInternalAsync(ScheduleParameters parameters, CancellationToken token)
        {
            var schedules = await ObjectEngine.GetObjectsAsync<Schedule>(parameters, token: token).ConfigureAwait(false);

            await Task.WhenAll(schedules.Select(async schedule =>
            {
                var response = (await GetObjectPropertiesRawInternalAsync(schedule.Id, ObjectType.Schedule, token).ConfigureAwait(false)).StringValue;
                ResponseParser.LoadTimeTable(schedule, response);
            })).ConfigureAwait(false);

            return schedules;
        }

        //######################################
        // ValidateTriggerParameters
        //######################################

        private void ValidateTriggerParameters(TriggerParameters parameters, CancellationToken token)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Action == ModifyAction.Add)
            {
                var data = GetNotificationTriggerData(parameters.ObjectId, token);

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = RequestParser.GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = GetSensors(Property.Id, parameters.ObjectId, token);

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if (channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (GetChannelsInternal(parameters.ObjectId, n => n == ((Channel)channel.channel).Name, i => i == ((Channel)channel.channel).Id, token)).Any();
                else
                    anyResponse = (GetChannelProperties(parameters.ObjectId, Convert.ToInt32(((ISerializable)channel).GetSerializedFormat()), token)).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel {(channel.channel is int ? "ID " : "")}'{channel}' is not a valid channel for sensor with ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                {
                    var prefix = channel.channel is int ? $"Channel ID '{channel}'" : $"Channel '{channel.channel}' of type '{channel.channel.GetType().Name}'";

                    throw new InvalidOperationException($"{prefix} is not a valid channel for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut' of type '{nameof(StandardTriggerChannel)}'."); //todo: make this dynamically get all names in the enum
                }
            }
        }

        private async Task ValidateTriggerParametersAsync(TriggerParameters parameters, CancellationToken token)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Action == ModifyAction.Add)
            {
                var data = await GetNotificationTriggerDataAsync(parameters.ObjectId, token).ConfigureAwait(false);

                if (!data.SupportedTypes.Contains(parameters.Type))
                    throw new InvalidTriggerTypeException(parameters.ObjectId, parameters.Type, data.SupportedTypes.ToList());
            }

            var channel = RequestParser.GetTriggerChannel(parameters);

            if (channel == null)
                return;

            var sensor = await GetSensorsAsync(Property.Id, parameters.ObjectId, token).ConfigureAwait(false);

            if (sensor.Count > 0) //Validate this sensor has this channel
            {
                if (channel.channel is StandardTriggerChannel)
                    throw new InvalidOperationException($"Channel '{channel}' is not a valid value for sensor with ID {parameters.ObjectId}. Triggers assigned directly to sensors must refer to a specific Channel or Channel ID.");

                bool anyResponse = false;

                if (channel.channel is Channel)
                    anyResponse = (await GetChannelsInternalAsync(parameters.ObjectId, n => n == ((Channel)channel.channel).Name, i => i == ((Channel)channel.channel).Id, token).ConfigureAwait(false)).Any();
                else
                    anyResponse = (await GetChannelPropertiesAsync(parameters.ObjectId, Convert.ToInt32(((ISerializable)channel).GetSerializedFormat()), token).ConfigureAwait(false)).Descendants().Any();

                if (!anyResponse)
                    throw new InvalidOperationException($"Channel {(channel.channel is int ? "ID " : "")}'{channel}' is not a valid channel for sensor with ID {parameters.ObjectId}. Channel could not be found.");
            }
            else //It's a container. Only enum values are permitted.
            {
                if (!(channel.channel is StandardTriggerChannel))
                {
                    var prefix = channel.channel is int ? $"Channel ID '{channel}'" : $"Channel '{channel.channel}' of type '{channel.channel.GetType().Name}'";

                    throw new InvalidOperationException($"{prefix} is not a valid channel for Device, Group or Probe with ID {parameters.ObjectId}. Channel must be one of 'Primary', 'Total', 'TrafficIn' or 'TrafficOut' of type '{nameof(StandardTriggerChannel)}'."); //todo: make this dynamically get all names in the enum
                }
            }
        }

        //######################################
        // UpdateTriggerChannels
        //######################################

        private void UpdateTriggerChannels(List<NotificationTrigger> triggers, CancellationToken token)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.HasChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}", LogLevel.Trace);

                    bool isSensor = false;

                    trigger.channelObj = (GetChannelsInternal(trigger.ObjectId, n => { isSensor = true; return n == trigger.channelName; }, token: token)).FirstOrDefault();

                    if (trigger.channelObj == null)
                    {
                        //Either we're not a sensor, or our channel is corrupt.
                        //If we detected we had ANY channels, we must be a sensor.
                        //If SetEnumChannel fails (which should be impossible)
                        //then maybe we're a sensor with zero channels or something?

                        if ((isSensor && !trigger.Inherited) || !trigger.SetEnumChannel())
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.");
                    }
                }
            }
        }

        private async Task UpdateTriggerChannelsAsync(List<NotificationTrigger> triggers, CancellationToken token)
        {
            foreach (var trigger in triggers)
            {
                if (trigger.HasChannel())
                {
                    Log($"Retrieving Channel for sensor specific, channel based Notification Trigger (Sub ID: {trigger.SubId}", LogLevel.Trace);

                    bool isSensor = false;

                    trigger.channelObj = (await GetChannelsInternalAsync(trigger.ObjectId, n => { isSensor = true; return n == trigger.channelName; }, token: token).ConfigureAwait(false)).FirstOrDefault();

                    if (trigger.channelObj == null)
                    {
                        //Either we're not a sensor, or our channel is corrupt.
                        //If we detected we had ANY channels, we must be a sensor.
                        //If SetEnumChannel fails (which should be impossible)
                        //then maybe we're a sensor with zero channels or something?

                        if ((isSensor && !trigger.Inherited) || !trigger.SetEnumChannel())
                            throw new InvalidStateException($"Could not deserialize channel of {trigger.Type.ToString().ToLower()} trigger '{trigger.SubId}' of object ID '{trigger.ObjectId}'. Object may be in a corrupted state. Please check the notification triggers of object ID {trigger.ObjectId} in the PRTG UI.");
                    }
                }
            }
        }

        //######################################
        // ParseNotificationTriggerTypes
        //######################################

        private PrtgResponse ParseNotificationTriggerTypes(HttpResponseMessage response)
        {
            var responseText = response.Content.ReadAsStringAsync().Result;

            var match = Regex.Match(responseText, "\"data\": \"(.+?)\",");

            if (match.Success)
                responseText = responseText.Replace(match.Value, "");

            return responseText;
        }

        private async Task<PrtgResponse> ParseNotificationTriggerTypesAsync(HttpResponseMessage response)
        {
            var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);

            var match = Regex.Match(responseText, "\"data\": \"(.+?)\",");

            if (match.Success)
                responseText = responseText.Replace(match.Value, "");

            return responseText;
        }

        //######################################
        // WaitForCoreRestart
        //######################################

        internal void WaitForCoreRestart(DateTime restartTime, Func<RestartCoreStage, bool> callback, CancellationToken token)
        {
            RestartCoreStage coreStage = RestartCoreStage.Shutdown;

            var originalRetries = RetryCount;

            try
            {
                RetryCount = 0;

                while (coreStage != RestartCoreStage.Completed && !token.IsCancellationRequested)
                {
                    coreStage = ProbeServer(restartTime, token);

                    if (callback != null && !callback(coreStage))
                        break;

                    if (coreStage == RestartCoreStage.Completed)
                        break;
#if !DEBUG
                    if (callback == null)
                        token.WaitHandle.WaitOne(5000, true);
#endif
                }
            }
            finally
            {
                RetryCount = originalRetries;
            }
        }

        internal async Task WaitForCoreRestartAsync(DateTime restartTime, Func<RestartCoreStage, bool> callback, CancellationToken token)
        {
            RestartCoreStage coreStage = RestartCoreStage.Shutdown;

            var originalRetries = RetryCount;

            try
            {
                RetryCount = 0;

                while (coreStage != RestartCoreStage.Completed && !token.IsCancellationRequested)
                {
                    coreStage = await ProbeServerAsync(restartTime, token).ConfigureAwait(false);

                    if (callback != null && !callback(coreStage))
                        break;

                    if (coreStage == RestartCoreStage.Completed)
                        break;
#if !DEBUG
                    if (callback == null)
                        await token.WaitHandle.WaitOneAsync(5000, token).ConfigureAwait(false);
#endif
                }
            }
            finally
            {
                RetryCount = originalRetries;
            }
        }

        //######################################
        // ProbeServer
        //######################################

        private RestartCoreStage ProbeServer(DateTime restartTime, CancellationToken token)
        {
            RestartCoreStage coreStage;
            
            try
            {
                var logs = GetLogs(new LogParameters(null, null, restartTime, status: LogStatus.SystemStart), token);

                coreStage = logs.Any() ? RestartCoreStage.Completed : RestartCoreStage.Shutdown;
            }
            catch (Exception ex) when (ex is WebException || ex is TimeoutException)
            {
                coreStage = RestartCoreStage.Restart;
            }
            catch (HttpRequestException)
            {
                coreStage = RestartCoreStage.Startup;
            }

            return coreStage;
        }

        private async Task<RestartCoreStage> ProbeServerAsync(DateTime restartTime, CancellationToken token)
        {
            RestartCoreStage coreStage;
            
            try
            {
                var logs = await GetLogsAsync(new LogParameters(null, null, restartTime, status: LogStatus.SystemStart), token).ConfigureAwait(false);

                coreStage = logs.Any() ? RestartCoreStage.Completed : RestartCoreStage.Shutdown;
            }
            catch (Exception ex) when (ex is WebException || ex is TimeoutException)
            {
                coreStage = RestartCoreStage.Restart;
            }
            catch (HttpRequestException)
            {
                coreStage = RestartCoreStage.Startup;
            }

            return coreStage;
        }

        //######################################
        // WaitForCoreRestart
        //######################################

        internal void WaitForProbeRestart(DateTime restartTime, List<Probe> probes, Func<ProbeRestartProgress[], bool>  progressCallback, CancellationToken token)
        {
            List<ProbeRestartProgress> probeStatuses = probes.Select(p => new ProbeRestartProgress(p)).ToList();

            while (probeStatuses.Any(p => p.Reconnected == false) && !token.IsCancellationRequested)
            {
                //Get all logs relating to probes connecting and disconnecting since we initiated the restarts.
                //If we've already detected all probes have disconnected, no need to include those logs in the response
                var statuses = new List<LogStatus> { LogStatus.Connected };

                if (probeStatuses.Any(p => !p.Disconnected))
                    statuses.Add(LogStatus.Disconnected);

                var logs = GetLogs(new LogParameters(null, null, restartTime, status: statuses.ToArray()), token);

                ResponseParser.UpdateProbeStatus(probeStatuses, logs);

                if (progressCallback == null)
                    token.WaitHandle.WaitOne(5000, true);
                else
                {
                    var result = progressCallback(probeStatuses.ToArray());

                    if (!result)
                        break;
                }
            }
        }

        internal async Task WaitForProbeRestartAsync(DateTime restartTime, List<Probe> probes, Func<ProbeRestartProgress[], bool>  progressCallback, CancellationToken token)
        {
            List<ProbeRestartProgress> probeStatuses = probes.Select(p => new ProbeRestartProgress(p)).ToList();

            while (probeStatuses.Any(p => p.Reconnected == false) && !token.IsCancellationRequested)
            {
                //Get all logs relating to probes connecting and disconnecting since we initiated the restarts.
                //If we've already detected all probes have disconnected, no need to include those logs in the response
                var statuses = new List<LogStatus> { LogStatus.Connected };

                if (probeStatuses.Any(p => !p.Disconnected))
                    statuses.Add(LogStatus.Disconnected);

                var logs = await GetLogsAsync(new LogParameters(null, null, restartTime, status: statuses.ToArray()), token).ConfigureAwait(false);

                ResponseParser.UpdateProbeStatus(probeStatuses, logs);

                if (progressCallback == null)
                    await token.WaitHandle.WaitOneAsync(5000, token).ConfigureAwait(false);
                else
                {
                    var result = progressCallback(probeStatuses.ToArray());

                    if (!result)
                        break;
                }
            }
        }

        //######################################
        // AddObjectWithExcessiveValue
        //######################################

        internal void AddObjectWithExcessiveValue(List<KeyValuePair<Parameter, object>> lengthLimit, ICommandParameters internalParams, CancellationToken token)
        {
            var limitParam = lengthLimit.First();

            var limit = limitParam.Key.GetEnumAttribute<LengthLimitAttribute>().Length;

            if (limitParam.Value.IsIEnumerable())
            {
                var list = limitParam.Value.ToIEnumerable().ToList();

                var count = list.Count();

                if (count > limit)
                {
                    for (int i = 0; i < count; i += limit)
                    {
                        var thisRequest = list.Skip(i).Take(limit);

                        internalParams[limitParam.Key] = thisRequest;

                        AddObjectWithInternalParams(internalParams, i, token);
                    }
                }
                else
                    AddObjectWithInternalParams(internalParams, 0, token);
            }
            else
                throw new NotImplementedException($"Don't know how to handle {nameof(LengthLimitAttribute)} applied to value of type {limitParam.Value.GetType()}.");
        }

        internal async Task AddObjectWithExcessiveValueAsync(List<KeyValuePair<Parameter, object>> lengthLimit, ICommandParameters internalParams, CancellationToken token)
        {
            var limitParam = lengthLimit.First();

            var limit = limitParam.Key.GetEnumAttribute<LengthLimitAttribute>().Length;

            if (limitParam.Value.IsIEnumerable())
            {
                var list = limitParam.Value.ToIEnumerable().ToList();

                var count = list.Count();

                if (count > limit)
                {
                    for (int i = 0; i < count; i += limit)
                    {
                        var thisRequest = list.Skip(i).Take(limit);

                        internalParams[limitParam.Key] = thisRequest;

                        await AddObjectWithInternalParamsAsync(internalParams, i, token).ConfigureAwait(false);
                    }
                }
                else
                    await AddObjectWithInternalParamsAsync(internalParams, 0, token).ConfigureAwait(false);
            }
            else
                throw new NotImplementedException($"Don't know how to handle {nameof(LengthLimitAttribute)} applied to value of type {limitParam.Value.GetType()}.");
        }

        //######################################
        // ResolveSensorTargets
        //######################################

        /*
         * Resolving sensor targets is a four step process, accomplished by executing three requests against PRTG:
         *
         * | Step | Required                              | Page                     | Description                                         |
         * | ---- | ------------------------------------- | ------------------------ | --------------------------------------------------- |
         * |  1   | SensorType, Device ID                 | addsensor2.htm           | Request a tmpid for creating a sensor               |
         * |  2a  |                                       | addsensor3.htm           | Response containing the tmpid requested in step 1   |
         * |  2b  | Device ID, TmpID, Query Target Params | addsensor3.htm           | Response requesting Query Target Parameters         |
         * |  3   | tmpid, Cookie                         | getaddsensorprogress.htm | Wait for sensor targets to be retrieved             |
         * |  4   | tmpid, Cookie                         | addsensor4.htm           | Scrape the contents of the new sensor creation page |
         */

        /// <summary>
        /// Entry point for resolving sensor targets of a supported sensor type.
        /// </summary>
        /// <typeparam name="T">The type of sensor targets the response should be transformed into.</typeparam>
        /// <param name="deviceOrId">The device or ID of the device to retrieve sensor targets from.</param>
        /// <param name="sensorType">Type of sensor to retrieve sensor targets for.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="queryParameters">A <see cref="SensorQueryTarget"/>, <see cref="SensorQueryTargetParameters"/> or <see cref="SensorMultiQueryTargetParameters"/> value specifying the parameters must be known prior to interrogating a sensor's dynamic parameters (such as the SNMP Library file to use or IPMI UserName and Password).</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="parser">Transforms the result of <see cref="HtmlFunction.AddSensor4"/> to instances of type <typeparamref name="T"/>.</param>
        /// <returns>A list of targets that were extracted from PRTG.</returns>
        internal List<T> ResolveSensorTargets<T>(Either<Device, int> deviceOrId, SensorType sensorType, Func<int, bool> progressCallback, int timeout, ISensorQueryTargetParameters queryParameters, CancellationToken token, Func<string, List<T>> parser)
        {
            var parameters = ValidateAddSensorQueryParameters(new BeginAddSensorQueryParameters(deviceOrId, sensorType, queryParameters));

            return ResolveSensorTargets(deviceOrId, parameters, progressCallback, timeout, token, parser);
        }

        /// <summary>
        /// Entry point for resolving sensor targets of a raw sensor type.
        /// </summary>
        /// <typeparam name="T">The type of sensor targets the response should be transformed into.</typeparam>
        /// <param name="deviceOrId">The device or ID of the device to retrieve sensor targets from.</param>
        /// <param name="sensorType">Type of sensor to retrieve sensor targets for.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="queryParameters">A <see cref="SensorQueryTarget"/>, <see cref="SensorQueryTargetParameters"/> or <see cref="SensorMultiQueryTargetParameters"/> value specifying the parameters must be known prior to interrogating a sensor's dynamic parameters (such as the SNMP Library file to use or IPMI UserName and Password).</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="parser">Transforms the result of <see cref="HtmlFunction.AddSensor4"/> to instances of type <typeparamref name="T"/>.</param>
        /// <returns>A list of targets that were extracted from PRTG.</returns>
        internal List<T> ResolveSensorTargets<T>(Either<Device, int> deviceOrId, string sensorType, Func<int, bool> progressCallback, int timeout, ISensorQueryTargetParameters queryParameters, CancellationToken token, Func<string, List<T>> parser)
        {
            var parameters = ValidateAddSensorQueryParameters(new BeginAddSensorQueryParameters(deviceOrId, sensorType, queryParameters)); //todo: make them all use the async one. they should both have the same count of usages in the end

            return ResolveSensorTargets(deviceOrId, parameters, progressCallback, timeout, token, parser);
        }

        /// <summary>
        /// Common entry point for scraping <see cref="HtmlFunction.AddSensor4"/> for either a supported or raw sensor type and then transforming the response into a set of sensor targets.
        /// </summary>
        /// <typeparam name="T">The type of sensor targets the response should be transformed into.</typeparam>
        /// <param name="deviceOrId">The device or ID of the device to retrieve sensor targets from.</param>
        /// <param name="parameters">A set of parameters for requesting the <see cref="Parameter.TmpId"/> of either a supported or raw sensor type.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="parser">Transforms the result of <see cref="HtmlFunction.AddSensor4"/> to instances of type <typeparamref name="T"/>.</param>
        /// <returns>A list of targets that were extracted from PRTG.</returns>
        private List<T> ResolveSensorTargets<T>(Either<Device, int> deviceOrId, BeginAddSensorQueryParameters parameters, Func<int, bool> progressCallback, int timeout, CancellationToken token, Func<string, List<T>> parser)
        {
            var response = GetSensorTargetsResponse(deviceOrId, parameters, progressCallback, timeout, token);

            if (response == null)
                return null;

            return parser(response);
        }

        /// <summary>
        /// Entry point for resolving sensor targets of a supported sensor type.
        /// </summary>
        /// <typeparam name="T">The type of sensor targets the response should be transformed into.</typeparam>
        /// <param name="deviceOrId">The device or ID of the device to retrieve sensor targets from.</param>
        /// <param name="sensorType">Type of sensor to retrieve sensor targets for.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="queryParameters">A <see cref="SensorQueryTarget"/>, <see cref="SensorQueryTargetParameters"/> or <see cref="SensorMultiQueryTargetParameters"/> value specifying the parameters must be known prior to interrogating a sensor's dynamic parameters (such as the SNMP Library file to use or IPMI UserName and Password).</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="parser">Transforms the result of <see cref="HtmlFunction.AddSensor4"/> to instances of type <typeparamref name="T"/>.</param>
        /// <returns>A list of targets that were extracted from PRTG.</returns>
        internal async Task<List<T>> ResolveSensorTargetsAsync<T>(Either<Device, int> deviceOrId, SensorType sensorType, Func<int, bool> progressCallback, int timeout, ISensorQueryTargetParameters queryParameters, CancellationToken token, Func<string, List<T>> parser)
        {
            var parameters = await ValidateAddSensorQueryParametersAsync(new BeginAddSensorQueryParameters(deviceOrId, sensorType, queryParameters)).ConfigureAwait(false);

            return await ResolveSensorTargetsAsync(deviceOrId, parameters, progressCallback, timeout, token, parser).ConfigureAwait(false);
        }

        /// <summary>
        /// Entry point for resolving sensor targets of a raw sensor type.
        /// </summary>
        /// <typeparam name="T">The type of sensor targets the response should be transformed into.</typeparam>
        /// <param name="deviceOrId">The device or ID of the device to retrieve sensor targets from.</param>
        /// <param name="sensorType">Type of sensor to retrieve sensor targets for.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="queryParameters">A <see cref="SensorQueryTarget"/>, <see cref="SensorQueryTargetParameters"/> or <see cref="SensorMultiQueryTargetParameters"/> value specifying the parameters must be known prior to interrogating a sensor's dynamic parameters (such as the SNMP Library file to use or IPMI UserName and Password).</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="parser">Transforms the result of <see cref="HtmlFunction.AddSensor4"/> to instances of type <typeparamref name="T"/>.</param>
        /// <returns>A list of targets that were extracted from PRTG.</returns>
        internal async Task<List<T>> ResolveSensorTargetsAsync<T>(Either<Device, int> deviceOrId, string sensorType, Func<int, bool> progressCallback, int timeout, ISensorQueryTargetParameters queryParameters, CancellationToken token, Func<string, List<T>> parser)
        {
            var parameters = await ValidateAddSensorQueryParametersAsync(new BeginAddSensorQueryParameters(deviceOrId, sensorType, queryParameters)).ConfigureAwait(false); //todo: make them all use the async one. they should both have the same count of usages in the end

            return await ResolveSensorTargetsAsync(deviceOrId, parameters, progressCallback, timeout, token, parser).ConfigureAwait(false);
        }

        /// <summary>
        /// Common entry point for scraping <see cref="HtmlFunction.AddSensor4"/> for either a supported or raw sensor type and then transforming the response into a set of sensor targets.
        /// </summary>
        /// <typeparam name="T">The type of sensor targets the response should be transformed into.</typeparam>
        /// <param name="deviceOrId">The device or ID of the device to retrieve sensor targets from.</param>
        /// <param name="parameters">A set of parameters for requesting the <see cref="Parameter.TmpId"/> of either a supported or raw sensor type.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="parser">Transforms the result of <see cref="HtmlFunction.AddSensor4"/> to instances of type <typeparamref name="T"/>.</param>
        /// <returns>A list of targets that were extracted from PRTG.</returns>
        private async Task<List<T>> ResolveSensorTargetsAsync<T>(Either<Device, int> deviceOrId, BeginAddSensorQueryParameters parameters, Func<int, bool> progressCallback, int timeout, CancellationToken token, Func<string, List<T>> parser)
        {
            var response = await GetSensorTargetsResponseAsync(deviceOrId, parameters, progressCallback, timeout, token).ConfigureAwait(false);

            if (response == null)
                return null;

            return parser(response);
        }

        //######################################
        // GetAddSensorQueryResponse
        //######################################

        /// <summary>
        /// Special entry point for constructing parameters from a raw sensor type and retrieving the contents of <see cref="HtmlFunction.AddSensor4"/> without parsing into sensor targets..
        /// </summary>
        /// <param name="deviceOrId">The device or ID of the device to probe.</param>
        /// <param name="sensorType">Type of sensor to retrieve parameters for.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="queryParameters">A <see cref="SensorQueryTarget"/>, <see cref="SensorQueryTargetParameters"/> or <see cref="SensorMultiQueryTargetParameters"/> value specifying the parameters must be known prior to interrogating a sensor's dynamic parameters (such as the SNMP Library file to use or IPMI UserName and Password).</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The contents of the <see cref="HtmlFunction.AddSensor4"/> page.</returns>
        private string GetAddSensorQueryResponse(Either<Device, int> deviceOrId, string sensorType, Func<int, bool> progressCallback, int timeout, ISensorQueryTargetParameters queryParameters, CancellationToken token)
        {
            var parameters = ValidateAddSensorQueryParameters(new BeginAddSensorQueryParameters(deviceOrId, sensorType, queryParameters)); //todo: make them all use the async one. they should both have the same count of usages in the end

            return GetSensorTargetsResponse(deviceOrId, parameters, progressCallback, timeout, token);
        }

        /// <summary>
        /// Entry point for retrieving the raw contents of the <see cref="HtmlFunction.AddSensor4"/> page (without performing any post-request manipulations)
        /// </summary>
        /// <param name="deviceOrId">The device or ID of the device to probe.</param>
        /// <param name="parameters">A set of parameters for requesting the <see cref="Parameter.TmpId"/> of either a supported or raw sensor type.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The contents of the <see cref="HtmlFunction.AddSensor4"/> page.</returns>
        private string GetSensorTargetsResponse(Either<Device, int> deviceOrId, BeginAddSensorQueryParameters parameters, Func<int, bool> progressCallback, int timeout, CancellationToken token)
        {
            var tmpId = (GetAddSensorTmpId(parameters, token));

            if (tmpId == null)
                throw new PrtgRequestException($"Failed to resolve sensor targets for sensor type '{parameters[Parameter.SensorType]}': type was not valid or you do not have sufficient permissions on the specified object.");

            var response = WaitForSensorTargetResolution(deviceOrId, tmpId.Value, progressCallback, timeout, token);

            return response;
        }

        internal int? GetAddSensorTmpId(BeginAddSensorQueryParameters parameters, CancellationToken token)
        {
            Func<HttpResponseMessage, PrtgResponse> getSensorTargetTmpId = (m) => GetSensorTargetTmpId(m, parameters.QueryParameters, token);

            //Execute the request against addsensor2.htm to retrieve our tmpid
            var tmpIdStr = (RequestEngine.ExecuteRequest(parameters, getSensorTargetTmpId, token)).StringValue;

            int tmpId;

            if (int.TryParse(tmpIdStr, out tmpId))
                return tmpId;

            return null;
        }

        internal PrtgResponse GetSensorTargetTmpId(HttpResponseMessage message, SensorMultiQueryTargetParameters queryParameters, CancellationToken token)
        {
            var uri = message.RequestMessage.RequestUri.ToString();

            if (uri.Contains(CommandFunction.AddSensor3.GetDescription()))
                return ResponseParser.GetSensorTargetTmpId(message);
            {
                var content = message.Content.ReadAsStringAsync().Result;

                var components = UrlUtilities.CrackUrl(uri);

                try
                {
                    RequestEngine.ValidateHttpResponse(message, content);
                }
                catch (PrtgRequestException ex)
                {
                    var exceptionMessage = ex.Message;

                    var str = "PRTG was unable to complete the request. ";

                    if (exceptionMessage.StartsWith(str))
                        exceptionMessage = exceptionMessage.Substring(str.Length);

                    throw new PrtgRequestException($"Failed to process query for sensor type '{components["sensortype"]}': you may not have sufficient permissions on the specified object. {exceptionMessage.EnsurePeriod()}");
                }

                var parameters = ResponseParser.GetProcessSensorQueryParameters(content, components["sensortype"], queryParameters);

                //If we couldn't find our tmpid (e.g. because we're a read-only user) return null for the tmpid and let
                //the calling method handle it
                if (parameters == null)
                    return null;

                Func<HttpResponseMessage, PrtgResponse> getSensorTargetTmpId = ResponseParser.GetSensorTargetTmpId;

                return RequestEngine.ExecuteRequest(parameters, getSensorTargetTmpId, token);
            }
        }

        /// <summary>
        /// Special entry point for constructing parameters from a raw sensor type and retrieving the contents of <see cref="HtmlFunction.AddSensor4"/> without parsing into sensor targets..
        /// </summary>
        /// <param name="deviceOrId">The device or ID of the device to probe.</param>
        /// <param name="sensorType">Type of sensor to retrieve parameters for.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="queryParameters">A <see cref="SensorQueryTarget"/>, <see cref="SensorQueryTargetParameters"/> or <see cref="SensorMultiQueryTargetParameters"/> value specifying the parameters must be known prior to interrogating a sensor's dynamic parameters (such as the SNMP Library file to use or IPMI UserName and Password).</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The contents of the <see cref="HtmlFunction.AddSensor4"/> page.</returns>
        private async Task<string> GetAddSensorQueryResponseAsync(Either<Device, int> deviceOrId, string sensorType, Func<int, bool> progressCallback, int timeout, ISensorQueryTargetParameters queryParameters, CancellationToken token)
        {
            var parameters = await ValidateAddSensorQueryParametersAsync(new BeginAddSensorQueryParameters(deviceOrId, sensorType, queryParameters)).ConfigureAwait(false); //todo: make them all use the async one. they should both have the same count of usages in the end

            return await GetSensorTargetsResponseAsync(deviceOrId, parameters, progressCallback, timeout, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Entry point for retrieving the raw contents of the <see cref="HtmlFunction.AddSensor4"/> page (without performing any post-request manipulations)
        /// </summary>
        /// <param name="deviceOrId">The device or ID of the device to probe.</param>
        /// <param name="parameters">A set of parameters for requesting the <see cref="Parameter.TmpId"/> of either a supported or raw sensor type.</param>
        /// <param name="progressCallback">A callback function used to monitor the progress of the request. If this function returns false, the request is aborted and this method returns null.</param>
        /// <param name="timeout">Duration (in seconds) to wait for sensor targets to resolve.</param>
        /// <param name="token">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>The contents of the <see cref="HtmlFunction.AddSensor4"/> page.</returns>
        private async Task<string> GetSensorTargetsResponseAsync(Either<Device, int> deviceOrId, BeginAddSensorQueryParameters parameters, Func<int, bool> progressCallback, int timeout, CancellationToken token)
        {
            var tmpId = (await GetAddSensorTmpIdAsync(parameters, token).ConfigureAwait(false));

            if (tmpId == null)
                throw new PrtgRequestException($"Failed to resolve sensor targets for sensor type '{parameters[Parameter.SensorType]}': type was not valid or you do not have sufficient permissions on the specified object.");

            var response = await WaitForSensorTargetResolutionAsync(deviceOrId, tmpId.Value, progressCallback, timeout, token).ConfigureAwait(false);

            return response;
        }

        internal async Task<int?> GetAddSensorTmpIdAsync(BeginAddSensorQueryParameters parameters, CancellationToken token)
        {
            Func<HttpResponseMessage, Task<PrtgResponse>> getSensorTargetTmpId = async (m) => await GetSensorTargetTmpIdAsync(m, parameters.QueryParameters, token).ConfigureAwait(false);

            //Execute the request against addsensor2.htm to retrieve our tmpid
            var tmpIdStr = (await RequestEngine.ExecuteRequestAsync(parameters, getSensorTargetTmpId, token).ConfigureAwait(false)).StringValue;

            int tmpId;

            if (int.TryParse(tmpIdStr, out tmpId))
                return tmpId;

            return null;
        }

        internal async Task<PrtgResponse> GetSensorTargetTmpIdAsync(HttpResponseMessage message, SensorMultiQueryTargetParameters queryParameters, CancellationToken token)
        {
            var uri = message.RequestMessage.RequestUri.ToString();

            if (uri.Contains(CommandFunction.AddSensor3.GetDescription()))
                return ResponseParser.GetSensorTargetTmpId(message);
            {
                var content = message.Content.ReadAsStringAsync().Result;

                var components = UrlUtilities.CrackUrl(uri);

                try
                {
                    RequestEngine.ValidateHttpResponse(message, content);
                }
                catch (PrtgRequestException ex)
                {
                    var exceptionMessage = ex.Message;

                    var str = "PRTG was unable to complete the request. ";

                    if (exceptionMessage.StartsWith(str))
                        exceptionMessage = exceptionMessage.Substring(str.Length);

                    throw new PrtgRequestException($"Failed to process query for sensor type '{components["sensortype"]}': you may not have sufficient permissions on the specified object. {exceptionMessage.EnsurePeriod()}");
                }

                var parameters = ResponseParser.GetProcessSensorQueryParameters(content, components["sensortype"], queryParameters);

                //If we couldn't find our tmpid (e.g. because we're a read-only user) return null for the tmpid and let
                //the calling method handle it
                if (parameters == null)
                    return null;

                Func<HttpResponseMessage, Task<PrtgResponse>> getSensorTargetTmpId = o => Task.FromResult(ResponseParser.GetSensorTargetTmpId(o));

                return await RequestEngine.ExecuteRequestAsync(parameters, getSensorTargetTmpId, token).ConfigureAwait(false);
            }
        }

        //######################################
        // WaitForSensorTargetResolution
        //######################################

        private string WaitForSensorTargetResolution(Either<Device, int> deviceOrId, int tmpId, Func<int, bool> progressCallback, int timeout, CancellationToken token)
        {
            var parameters = new AddSensorProgressParameters(deviceOrId, tmpId);

            AddSensorProgress p;
            bool continueQuery = true;

            var stopwatch = new Stopwatch();
            var timeoutTimeSpan = TimeSpan.FromSeconds(timeout);

            stopwatch.Start();

            do
            {
                //Probe getaddsensorprogress.htm
                p = ObjectEngine.GetObject<AddSensorProgress>(parameters, token: token);

                if (progressCallback != null)
                    continueQuery = progressCallback(p.Percent);

                if (p.Percent < 100)
                {
                    if (!continueQuery)
                        break;

                        if (stopwatch.Elapsed > timeoutTimeSpan)
                            throw new TimeoutException("Failed to retrieve sensor information within a reasonable period of time. Check target device is accessible and that valid credentials have been supplied.");

#if !DEBUG
                    token.WaitHandle.WaitOne(1000, true);
#endif
                }
            } while (p.Percent < 100);

            if (!continueQuery)
                return null;

            ResponseParser.ValidateAddSensorProgressResult(p, false);

            //Scrape addsensor4.htm
            var page = (RequestEngine.ExecuteRequest(new EndAddSensorQueryParameters(deviceOrId, tmpId), token: token)).StringValue;

            return page;
        }

        private async Task<string> WaitForSensorTargetResolutionAsync(Either<Device, int> deviceOrId, int tmpId, Func<int, bool> progressCallback, int timeout, CancellationToken token)
        {
            var parameters = new AddSensorProgressParameters(deviceOrId, tmpId);

            AddSensorProgress p;
            bool continueQuery = true;

            var stopwatch = new Stopwatch();
            var timeoutTimeSpan = TimeSpan.FromSeconds(timeout);

            stopwatch.Start();

            do
            {
                //Probe getaddsensorprogress.htm
                p = await ObjectEngine.GetObjectAsync<AddSensorProgress>(parameters, token: token).ConfigureAwait(false);

                if (progressCallback != null)
                    continueQuery = progressCallback(p.Percent);

                if (p.Percent < 100)
                {
                    if (!continueQuery)
                        break;

                        if (stopwatch.Elapsed > timeoutTimeSpan)
                            throw new TimeoutException("Failed to retrieve sensor information within a reasonable period of time. Check target device is accessible and that valid credentials have been supplied.");

#if !DEBUG
                    await token.WaitHandle.WaitOneAsync(1000, token).ConfigureAwait(false);
#endif
                }
            } while (p.Percent < 100);

            if (!continueQuery)
                return null;

            ResponseParser.ValidateAddSensorProgressResult(p, false);

            //Scrape addsensor4.htm
            var page = (await RequestEngine.ExecuteRequestAsync(new EndAddSensorQueryParameters(deviceOrId, tmpId), token: token).ConfigureAwait(false)).StringValue;

            return page;
        }

        //######################################
        // AddObject
        //######################################

        internal List<T> AddObject<T>(Either<IPrtgObject, int> parent, NewObjectParameters parameters,
            Func<SearchFilter[], CancellationToken, List<T>> getObjects, bool resolve, CancellationToken token, Action<Type, int> errorCallback = null,
            Func<bool> shouldStop = null, bool allowMultiple = false) where T : SensorOrDeviceOrGroupOrProbe
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (resolve)
            {
                var filters = RequestParser.GetFilters(parent, parameters);

                Action<CancellationToken> addObjectInternal = t => AddObjectInternal(parent, parameters, t);
                Func<CancellationToken, List<T>> getObjs = t => getObjects(filters, t);

                return (ResolveWithDiff(addObjectInternal, getObjs, ResponseParser.ExceptTableObject, token, errorCallback, shouldStop, allowMultiple)).OrderBy(o => o.Id).ToList();
            }
            else
            {
                AddObjectInternal(parent, parameters, token);

                return null;
            }
        }

        private void AddObjectInternal(Either<IPrtgObject, int> parent, NewObjectParameters parameters, CancellationToken token)
        {
            var lengthLimit = RequestParser.ValidateObjectParameters(parameters);

            var internalParams = RequestParser.GetInternalNewObjectParameters(parent, parameters);

            if (lengthLimit.Count > 0)
                AddObjectWithExcessiveValue(lengthLimit, internalParams, token);
            else
            {
                if (RequestParser.IsAddSensor(internalParams))
                    GetVersionClient().AddSensorInternal(internalParams, 0, token);
                else
                    AddObjectInternalDefault(internalParams, token);
            }
        }

        private void AddObjectWithInternalParams(ICommandParameters internalParams, int index, CancellationToken token)
        {
            if (RequestParser.IsAddSensor(internalParams))
                GetVersionClient().AddSensorInternal(internalParams, index, token);
            else
                AddObjectInternalDefault(internalParams, token);
        }

        internal void AddObjectInternalDefault(ICommandParameters internalParams, CancellationToken token) =>
            RequestEngine.ExecuteRequest(internalParams, token: token);

        private List<T> ResolveWithDiff<T>(Action<CancellationToken> createObject, Func<CancellationToken, List<T>> getObjects, Func<List<T>, List<T>, List<T>> exceptFunc,
             CancellationToken token, Action<Type, int> errorCallback, Func<bool> shouldStop, bool allowMultiple = false)
        {
            var before = getObjects(token);

            createObject(token);

            var after = ResolveObject(getObjects, token, a => exceptFunc(before, a).Any(), errorCallback: errorCallback, shouldStop: shouldStop);

            var newObjects = exceptFunc(before, after);

            if (!allowMultiple && newObjects.Count > 1)
            {
                var typeName = typeof (T).Name;

                IEnumerable<string> names;

                if (typeof (PrtgObject).IsAssignableFrom(typeof (T)))
                {
                    var objs = newObjects.Cast<PrtgObject>();

                    names = objs.Select(o => $"'{o.Name}' (ID: {o.Id})");
                }
                else
                    names = newObjects.Select(o => $"'{o}'");

                var str = $"Could not uniquely identify created {typeName}: multiple new objects ({string.Join(", ", names)}) were found under parent object. Did you create an additional object with the same type or name under the parent while resolution was occurring?";

                throw new ObjectResolutionException(str);
            }

            return CleanObjects(newObjects, token);
        }

        internal List<T> ResolveObject<T>(Func<CancellationToken, List<T>> getObjects, CancellationToken token, Func<List<T>, bool> recordsFound, string resolutionError = "Could not resolve object",
            Type trueType = null, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            List<T> @object;

            var retriesRemaining = 4;
            var delay = 3;

            do
            {
                @object = getObjects(token);

                if (!recordsFound(@object))
                {
                    if (retriesRemaining == 0)
                    {
                        throw new ObjectResolutionException($"{resolutionError}: PRTG is taking too long to create the object. Confirm the object has been created in the Web UI and then attempt resolution again manually.");
                    }

                    var type = trueType ?? typeof (T);

                    errorCallback?.Invoke(type, retriesRemaining);
                    retriesRemaining--;

#if DEBUG
                    if (!UnitTest())
#endif
                        token.WaitHandle.WaitOne(delay * 1000, true);

                    delay *= 2;
                }

                if (shouldStop?.Invoke() == true)
                    break;

            } while (!recordsFound(@object));

            return @object;
        }
        
        private List<T> CleanObjects<T>(List<T> newObjects, CancellationToken token)
        {
            if (newObjects.All(o => o is Sensor))
            {
                var sensors = newObjects.Cast<Sensor>().ToList();

                bool modified = false;

                foreach (var obj in sensors)
                {
                    //PRTG may sometimes prepend spaces to the front of the sensor name. This can even happen
                    //in the Web UI
                    if (obj.Name.StartsWith(" "))
                    {
                        modified = true;
                        RenameObject(obj.Id, obj.Name.Trim(' '));
                    }
                }

                if (modified)
                    newObjects = (GetSensors(Property.Id, sensors.Select(s => s.Id), token)).Cast<T>().ToList();
            }

            return newObjects;
        }

        internal async Task<List<T>> AddObjectAsync<T>(Either<IPrtgObject, int> parent, NewObjectParameters parameters,
            Func<SearchFilter[], CancellationToken, Task<List<T>>> getObjects, bool resolve, CancellationToken token, Action<Type, int> errorCallback = null,
            Func<bool> shouldStop = null, bool allowMultiple = false) where T : SensorOrDeviceOrGroupOrProbe
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (resolve)
            {
                var filters = RequestParser.GetFilters(parent, parameters);

                Func<CancellationToken, Task> addObjectInternal = async t => await AddObjectInternalAsync(parent, parameters, t).ConfigureAwait(false);
                Func<CancellationToken, Task<List<T>>> getObjs = async t => await getObjects(filters, t).ConfigureAwait(false);

                return (await ResolveWithDiffAsync(addObjectInternal, getObjs, ResponseParser.ExceptTableObject, token, errorCallback, shouldStop, allowMultiple).ConfigureAwait(false)).OrderBy(o => o.Id).ToList();
            }
            else
            {
                await AddObjectInternalAsync(parent, parameters, token).ConfigureAwait(false);

                return null;
            }
        }

        private async Task AddObjectInternalAsync(Either<IPrtgObject, int> parent, NewObjectParameters parameters, CancellationToken token)
        {
            var lengthLimit = RequestParser.ValidateObjectParameters(parameters);

            var internalParams = RequestParser.GetInternalNewObjectParameters(parent, parameters);

            if (lengthLimit.Count > 0)
                await AddObjectWithExcessiveValueAsync(lengthLimit, internalParams, token).ConfigureAwait(false);
            else
            {
                if (RequestParser.IsAddSensor(internalParams))
                    await GetVersionClient().AddSensorInternalAsync(internalParams, 0, token).ConfigureAwait(false);
                else
                    await AddObjectInternalDefaultAsync(internalParams, token).ConfigureAwait(false);
            }
        }

        private async Task AddObjectWithInternalParamsAsync(ICommandParameters internalParams, int index, CancellationToken token)
        {
            if (RequestParser.IsAddSensor(internalParams))
                await GetVersionClient().AddSensorInternalAsync(internalParams, index, token).ConfigureAwait(false);
            else
                await AddObjectInternalDefaultAsync(internalParams, token).ConfigureAwait(false);
        }

        internal async Task AddObjectInternalDefaultAsync(ICommandParameters internalParams, CancellationToken token) =>
            await RequestEngine.ExecuteRequestAsync(internalParams, token: token).ConfigureAwait(false);

        private async Task<List<T>> ResolveWithDiffAsync<T>(Func<CancellationToken, Task> createObject, Func<CancellationToken, Task<List<T>>> getObjects, Func<List<T>, List<T>, List<T>> exceptFunc,
             CancellationToken token, Action<Type, int> errorCallback, Func<bool> shouldStop, bool allowMultiple = false)
        {
            var before = await getObjects(token).ConfigureAwait(false);

            await createObject(token).ConfigureAwait(false);

            var after = await ResolveObjectAsync(getObjects, token, a => exceptFunc(before, a).Any(), errorCallback: errorCallback, shouldStop: shouldStop).ConfigureAwait(false);

            var newObjects = exceptFunc(before, after);

            if (!allowMultiple && newObjects.Count > 1)
            {
                var typeName = typeof (T).Name;

                IEnumerable<string> names;

                if (typeof (PrtgObject).IsAssignableFrom(typeof (T)))
                {
                    var objs = newObjects.Cast<PrtgObject>();

                    names = objs.Select(o => $"'{o.Name}' (ID: {o.Id})");
                }
                else
                    names = newObjects.Select(o => $"'{o}'");

                var str = $"Could not uniquely identify created {typeName}: multiple new objects ({string.Join(", ", names)}) were found under parent object. Did you create an additional object with the same type or name under the parent while resolution was occurring?";

                throw new ObjectResolutionException(str);
            }

            return await CleanObjectsAsync(newObjects, token).ConfigureAwait(false);
        }

        internal async Task<List<T>> ResolveObjectAsync<T>(Func<CancellationToken, Task<List<T>>> getObjects, CancellationToken token, Func<List<T>, bool> recordsFound, string resolutionError = "Could not resolve object",
            Type trueType = null, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            List<T> @object;

            var retriesRemaining = 4;
            var delay = 3;

            do
            {
                @object = await getObjects(token).ConfigureAwait(false);

                if (!recordsFound(@object))
                {
                    if (retriesRemaining == 0)
                    {
                        throw new ObjectResolutionException($"{resolutionError}: PRTG is taking too long to create the object. Confirm the object has been created in the Web UI and then attempt resolution again manually.");
                    }

                    var type = trueType ?? typeof (T);

                    errorCallback?.Invoke(type, retriesRemaining);
                    retriesRemaining--;

#if DEBUG
                    if (!UnitTest())
#endif
                        await token.WaitHandle.WaitOneAsync(delay * 1000, token).ConfigureAwait(false);

                    delay *= 2;
                }

                if (shouldStop?.Invoke() == true)
                    break;

            } while (!recordsFound(@object));

            return @object;
        }
        
        private async Task<List<T>> CleanObjectsAsync<T>(List<T> newObjects, CancellationToken token)
        {
            if (newObjects.All(o => o is Sensor))
            {
                var sensors = newObjects.Cast<Sensor>().ToList();

                bool modified = false;

                foreach (var obj in sensors)
                {
                    //PRTG may sometimes prepend spaces to the front of the sensor name. This can even happen
                    //in the Web UI
                    if (obj.Name.StartsWith(" "))
                    {
                        modified = true;
                        await RenameObjectAsync(obj.Id, obj.Name.Trim(' '), token).ConfigureAwait(false);
                    }
                }

                if (modified)
                    newObjects = (await GetSensorsAsync(Property.Id, sensors.Select(s => s.Id), token).ConfigureAwait(false)).Cast<T>().ToList();
            }

            return newObjects;
        }

        //######################################
        // AddNotificationTriggerInternal
        //######################################

        internal List<NotificationTrigger> AddNotificationTriggerInternal(TriggerParameters parameters, bool resolve,
            CancellationToken token, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (resolve)
            {
                Action<CancellationToken> addTrigger = t => SetNotificationTriggerInternal(parameters, t);
                Func<CancellationToken, List<NotificationTrigger>> getTrigger = t => GetNotificationTriggersInternal(parameters.ObjectId, t).Where(r => !r.Inherited).ToList();

                var objs = ResolveWithDiff(addTrigger, getTrigger, (b, a) => ResponseParser.ExceptTrigger(b, a, parameters), token, errorCallback, shouldStop);

                return objs;
            }
            else
            {
                SetNotificationTriggerInternal(parameters, token);

                return null;
            }
        }

        internal async Task<List<NotificationTrigger>> AddNotificationTriggerInternalAsync(TriggerParameters parameters, bool resolve,
            CancellationToken token, Action<Type, int> errorCallback = null, Func<bool> shouldStop = null)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (resolve)
            {
                Func<CancellationToken, Task> addTrigger = async t => await SetNotificationTriggerInternalAsync(parameters, t).ConfigureAwait(false);
                Func<CancellationToken, Task<List<NotificationTrigger>>> getTrigger = async t => (await GetNotificationTriggersInternalAsync(parameters.ObjectId, t).ConfigureAwait(false)).Where(r => !r.Inherited).ToList();

                var objs = await ResolveWithDiffAsync(addTrigger, getTrigger, (b, a) => ResponseParser.ExceptTrigger(b, a, parameters), token, errorCallback, shouldStop).ConfigureAwait(false);

                return objs;
            }
            else
            {
                await SetNotificationTriggerInternalAsync(parameters, token).ConfigureAwait(false);

                return null;
            }
        }

        //######################################
        // GetObject
        //######################################

        internal PrtgObject GetObjectInternal(int objectId, bool resolve)
        {
            var objs = GetObjects(Property.Id, objectId);

            if (objs.Count != 1)
                return objs.SingleObject(objectId);

            var obj = objs.Single();

            if (resolve)
            {
                switch (obj.Type.Value)
                {
                    case ObjectType.Sensor:       return GetSensor(objectId);
                    case ObjectType.Device:       return GetDevice(objectId);
                    case ObjectType.Group:        return GetGroup(objectId);
                    case ObjectType.Probe:        return GetProbe(objectId);
                    case ObjectType.Notification: return GetNotificationAction(objectId);
                    case ObjectType.Schedule:     return GetSchedule(objectId);
                    default:
                        return obj;
                }
            }

            return obj;
        }

        internal async Task<PrtgObject> GetObjectInternalAsync(int objectId, bool resolve, CancellationToken token)
        {
            var objs = await GetObjectsAsync(Property.Id, objectId, token).ConfigureAwait(false);

            if (objs.Count != 1)
                return objs.SingleObject(objectId);

            var obj = objs.Single();

            if (resolve)
            {
                switch (obj.Type.Value)
                {
                    case ObjectType.Sensor:       return await GetSensorAsync(objectId, token).ConfigureAwait(false);
                    case ObjectType.Device:       return await GetDeviceAsync(objectId, token).ConfigureAwait(false);
                    case ObjectType.Group:        return await GetGroupAsync(objectId, token).ConfigureAwait(false);
                    case ObjectType.Probe:        return await GetProbeAsync(objectId, token).ConfigureAwait(false);
                    case ObjectType.Notification: return await GetNotificationActionAsync(objectId, token).ConfigureAwait(false);
                    case ObjectType.Schedule:     return await GetScheduleAsync(objectId, token).ConfigureAwait(false);
                    default:
                        return obj;
                }
            }

            return obj;
        }

        //######################################
        // GetSystemInfoInternal
        //######################################

        internal List<T> GetSystemInfoInternal<T>(Either<Device, int> deviceOrId, CancellationToken token) where T : IDeviceInfo
        {
            var deviceId = deviceOrId.GetId();

            var parameters = new SystemInfoParameters<T>(deviceId);

            Func<HttpResponseMessage, PrtgResponse> func = (m) => ParseSystemInfoResponse(m, parameters.Columns);

            var info = ObjectEngine.GetObject<SysInfoData<T>>(parameters, func, token: token);

            foreach (var item in info.Items)
                item.DeviceId = deviceId;

            return info.Items;
        }

        internal List<IDeviceInfo> GetSystemInfoInternal(Either<Device, int> deviceOrId, SystemInfoType type)
        {
            var deviceId = deviceOrId.GetId();

            switch (type)
            {
                case SystemInfoType.System:
                    return (GetSystemInfo<DeviceSystemInfo>(deviceId)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Hardware:
                    return (GetSystemInfo<DeviceHardwareInfo>(deviceId)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Software:
                    return (GetSystemInfo<DeviceSoftwareInfo>(deviceId)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Processes:
                    return (GetSystemInfo<DeviceProcessInfo>(deviceId)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Services:
                    return (GetSystemInfo<DeviceServiceInfo>(deviceId)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Users:
                    return (GetSystemInfo<DeviceUserInfo>(deviceId)).Cast<IDeviceInfo>().ToList();
                default:
                    throw new NotImplementedException($"Don't know how to get system info for device info type '{type}'.");
            }
        }

        internal async Task<List<T>> GetSystemInfoInternalAsync<T>(Either<Device, int> deviceOrId, CancellationToken token) where T : IDeviceInfo
        {
            var deviceId = deviceOrId.GetId();

            var parameters = new SystemInfoParameters<T>(deviceId);

            Func<HttpResponseMessage, Task<PrtgResponse>> func = async (m) => await ParseSystemInfoResponseAsync(m, parameters.Columns).ConfigureAwait(false);

            var info = await ObjectEngine.GetObjectAsync<SysInfoData<T>>(parameters, func, token: token).ConfigureAwait(false);

            foreach (var item in info.Items)
                item.DeviceId = deviceId;

            return info.Items;
        }

        internal async Task<List<IDeviceInfo>> GetSystemInfoInternalAsync(Either<Device, int> deviceOrId, SystemInfoType type, CancellationToken token)
        {
            var deviceId = deviceOrId.GetId();

            switch (type)
            {
                case SystemInfoType.System:
                    return (await GetSystemInfoAsync<DeviceSystemInfo>(deviceId, token).ConfigureAwait(false)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Hardware:
                    return (await GetSystemInfoAsync<DeviceHardwareInfo>(deviceId, token).ConfigureAwait(false)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Software:
                    return (await GetSystemInfoAsync<DeviceSoftwareInfo>(deviceId, token).ConfigureAwait(false)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Processes:
                    return (await GetSystemInfoAsync<DeviceProcessInfo>(deviceId, token).ConfigureAwait(false)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Services:
                    return (await GetSystemInfoAsync<DeviceServiceInfo>(deviceId, token).ConfigureAwait(false)).Cast<IDeviceInfo>().ToList();
                case SystemInfoType.Users:
                    return (await GetSystemInfoAsync<DeviceUserInfo>(deviceId, token).ConfigureAwait(false)).Cast<IDeviceInfo>().ToList();
                default:
                    throw new NotImplementedException($"Don't know how to get system info for device info type '{type}'.");
            }
        }

        //######################################
        // ParseSystemInfoResponse
        //######################################

        private string ParseSystemInfoResponse(HttpResponseMessage response, SysInfoProperty[] columns)
        {
            var responseText = response.Content.ReadAsStringAsync().Result;

            try
            {
                return SysInfoJsonCleaner.Clean(responseText, columns);
            }
            catch
            {
                Log(responseText, LogLevel.Response);

                throw;
            }
        }

        private async Task<string> ParseSystemInfoResponseAsync(HttpResponseMessage response, SysInfoProperty[] columns)
        {
            var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);

            try
            {
                return SysInfoJsonCleaner.Clean(responseText, columns);
            }
            catch
            {
                Log(responseText, LogLevel.Response);

                throw;
            }
        }

        //######################################
        // GetObjectPropertyRawInternal
        //######################################

        private string GetObjectPropertyRawInternal(Either<IPrtgObject, int> objectOrId, Enum property)
        {
            var cache = ObjectPropertyParser.GetPropertyInfoViaTypeLookup(property);
            var rawName = ObjectPropertyParser.GetObjectPropertyNameViaCache(property, cache);

            var rawValue = GetObjectPropertyRaw(objectOrId, rawName, cache.Property.PropertyType == typeof(string));

            return rawValue;
        }

        private async Task<string> GetObjectPropertyRawInternalAsync(Either<IPrtgObject, int> objectOrId, Enum property, CancellationToken token)
        {
            var cache = ObjectPropertyParser.GetPropertyInfoViaTypeLookup(property);
            var rawName = ObjectPropertyParser.GetObjectPropertyNameViaCache(property, cache);

            var rawValue = await GetObjectPropertyRawAsync(objectOrId, rawName, cache.Property.PropertyType == typeof(string), token).ConfigureAwait(false);

            return rawValue;
        }

        //######################################
        // GetObjectPropertyInternal
        //######################################

        private object GetObjectPropertyInternal(Either<IPrtgObject, int> objectOrId, Enum property)
        {
            var rawValue = GetObjectPropertyRawInternal(objectOrId, property);

            if (property is ObjectProperty)
                return ObjectEngine.XmlEngine.DeserializeObjectProperty((ObjectProperty) property, rawValue);
            else
                return ObjectEngine.XmlEngine.DeserializeObjectProperty((ObjectPropertyInternal) property, rawValue);
        }

        private async Task<object> GetObjectPropertyInternalAsync(Either<IPrtgObject, int> objectOrId, Enum property, CancellationToken token)
        {
            var rawValue = await GetObjectPropertyRawInternalAsync(objectOrId, property, token).ConfigureAwait(false);

            if (property is ObjectProperty)
                return ObjectEngine.XmlEngine.DeserializeObjectProperty((ObjectProperty) property, rawValue);
            else
                return ObjectEngine.XmlEngine.DeserializeObjectProperty((ObjectPropertyInternal) property, rawValue);
        }

        //######################################
        // GetProbeApprovalStatus
        //######################################

        internal bool GetProbeApprovalStatus(Either<Probe, int> probeOrId)
        {
            try
            {
                var result = GetObjectPropertyRawInternal(probeOrId.GetId(), ObjectPropertyInternal.ProbeApproved);

                if (result != "0" && result != "1")
                    throw new PrtgRequestException($"Probe authorization status was '{result}', however should have been '0' or '1'. Object is most likely not a probe.");

                return result == "1";
            }
            catch(PrtgRequestException ex)
            {
                throw new InvalidOperationException($"Cannot change approval status of object with ID '{probeOrId.GetId()}': object does not appear to be a probe.", ex);
            }
        }

        internal async Task<bool> GetProbeApprovalStatusAsync(Either<Probe, int> probeOrId, CancellationToken token)
        {
            try
            {
                var result = await GetObjectPropertyRawInternalAsync(probeOrId.GetId(), ObjectPropertyInternal.ProbeApproved, token).ConfigureAwait(false);

                if (result != "0" && result != "1")
                    throw new PrtgRequestException($"Probe authorization status was '{result}', however should have been '0' or '1'. Object is most likely not a probe.");

                return result == "1";
            }
            catch(PrtgRequestException ex)
            {
                throw new InvalidOperationException($"Cannot change approval status of object with ID '{probeOrId.GetId()}': object does not appear to be a probe.", ex);
            }
        }

        //#######################################
        // CreateSetObjectPropertyParameters
        //#######################################

        private SetObjectPropertyParameters CreateSetObjectPropertyParameters(int[] objectIds, PropertyParameter[] parameters, CancellationToken token)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Any(p => p == null))
                throw new ArgumentException("Cannot process a null parameter.", nameof(parameters));

            var paramLists = RequestParser.GetSetObjectPropertyParamLists(parameters); //Item1: Normal items. Item2: Mergeable items

            for (var i = 0; i < paramLists.Item1.Length; i++)
            {
                var prop = paramLists.Item1[i];

                var attrib = prop.Property.GetEnumAttribute<TypeAttribute>();

                if (attrib != null)
                {
                    if (attrib.Class == typeof(Location) && !(prop.Value is Location))
                    {
                        var str = Location.GetAddress(prop.Value);

                        var newValue = ResolveAddress(str, CancellationToken.None);

                        paramLists.Item1[i] = new PropertyParameter(prop.Property, newValue);
                    }
                }
            }

            parameters = RequestParser.MergeParameters(paramLists);

            var @params = new SetObjectPropertyParameters(objectIds, parameters);

            return @params;
        }

        private async Task<SetObjectPropertyParameters> CreateSetObjectPropertyParametersAsync(int[] objectIds, PropertyParameter[] parameters, CancellationToken token)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Any(p => p == null))
                throw new ArgumentException("Cannot process a null parameter.", nameof(parameters));

            var paramLists = RequestParser.GetSetObjectPropertyParamLists(parameters); //Item1: Normal items. Item2: Mergeable items

            for (var i = 0; i < paramLists.Item1.Length; i++)
            {
                var prop = paramLists.Item1[i];

                var attrib = prop.Property.GetEnumAttribute<TypeAttribute>();

                if (attrib != null)
                {
                    if (attrib.Class == typeof(Location) && !(prop.Value is Location))
                    {
                        var str = Location.GetAddress(prop.Value);

                        var newValue = await ResolveAddressAsync(str, token).ConfigureAwait(false);

                        paramLists.Item1[i] = new PropertyParameter(prop.Property, newValue);
                    }
                }
            }

            parameters = RequestParser.MergeParameters(paramLists);

            var @params = new SetObjectPropertyParameters(objectIds, parameters);

            return @params;
        }

        //#######################################
        // SetChannelPropertyInternal
        //#######################################

        internal void SetChannelPropertyInternal(IEnumerable<Channel> channels, int[] sensorIds, int? channelId, ChannelParameter[] parameters, CancellationToken token)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Any(p => p == null))
                throw new ArgumentException("Cannot process a null parameter.", nameof(parameters));

            if (parameters.Length == 0)
                throw new ArgumentException("At least one parameter must be specified.", nameof(parameters));

            var versionClient = GetVersionClient<ChannelParameter, ChannelProperty>(parameters.ToList());

            if (channels != null)
            {
                var channelsList = channels.AsCollection();

                if (channelsList.Any(c => c == null))
                    throw new ArgumentException("Cannot process a null channel.", nameof(channels));

                versionClient.SetChannelProperty(channelsList, parameters, token);
            }
            else
                versionClient.SetChannelProperty(sensorIds, channelId.Value, parameters, token);
        }

        internal async Task SetChannelPropertyInternalAsync(IEnumerable<Channel> channels, int[] sensorIds, int? channelId, ChannelParameter[] parameters, CancellationToken token)
        {
            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Any(p => p == null))
                throw new ArgumentException("Cannot process a null parameter.", nameof(parameters));

            if (parameters.Length == 0)
                throw new ArgumentException("At least one parameter must be specified.", nameof(parameters));

            var versionClient = GetVersionClient<ChannelParameter, ChannelProperty>(parameters.ToList());

            if (channels != null)
            {
                var channelsList = channels.AsCollection();

                if (channelsList.Any(c => c == null))
                    throw new ArgumentException("Cannot process a null channel.", nameof(channels));

                await versionClient.SetChannelPropertyAsync(channelsList, parameters, token).ConfigureAwait(false);
            }
            else
                await versionClient.SetChannelPropertyAsync(sensorIds, channelId.Value, parameters, token).ConfigureAwait(false);
        }

        //#######################################
        // SetTriggerPropertyInternal
        //#######################################

        internal void SetTriggerPropertyInternal(IEnumerable<NotificationTrigger> triggers, TriggerParameter[] parameters, CancellationToken token)
        {
            AssertHasValue(triggers, nameof(triggers));

            var triggersList = triggers.AsCollection();

            if (triggersList.Any(c => c == null))
                throw new ArgumentException("Cannot process a null trigger.", nameof(triggers));

            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Any(p => p == null))
                throw new ArgumentException("Cannot process a null parameter.", nameof(parameters));

            if (parameters.Length == 0)
                throw new ArgumentException("At least one parameter must be specified.", nameof(parameters));

            foreach (var trigger in triggersList)
            {
                var triggerParameters = TriggerParameters.Create(trigger, parameters);

                SetNotificationTrigger(triggerParameters);
            }
        }

        internal async Task SetTriggerPropertyInternalAsync(IEnumerable<NotificationTrigger> triggers, TriggerParameter[] parameters, CancellationToken token)
        {
            AssertHasValue(triggers, nameof(triggers));

            var triggersList = triggers.AsCollection();

            if (triggersList.Any(c => c == null))
                throw new ArgumentException("Cannot process a null trigger.", nameof(triggers));

            if (parameters == null)
                throw new ArgumentNullException(nameof(parameters), "Parameters cannot be null.");

            if (parameters.Any(p => p == null))
                throw new ArgumentException("Cannot process a null parameter.", nameof(parameters));

            if (parameters.Length == 0)
                throw new ArgumentException("At least one parameter must be specified.", nameof(parameters));

            foreach (var trigger in triggersList)
            {
                var triggerParameters = TriggerParameters.Create(trigger, parameters);

                await SetNotificationTriggerAsync(triggerParameters, token).ConfigureAwait(false);
            }
        }
    }
}
